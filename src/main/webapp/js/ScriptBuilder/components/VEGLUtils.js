/*
 * This file is part of the AuScope Virtual Exploration Geophysics Lab (VEGL) project.
 * Copyright (c) 2011 CSIRO Earth Science and Resource Engineering
 *
 * Licensed under the terms of the GNU Lesser General Public License.
 */
Ext.define('ScriptBuilder.components.VEGLUtils', {
    extend : 'ScriptBuilder.components.BasePythonComponent',

    constructor: function(config) {
        Ext.apply(config, {
            bodyStyle: "padding:5px;",
            labelWidth: 150,
            defaults: { anchor: "100%" },
            items: [{
                xtype: "label",
                text: "Press OK to load these utility functions."
            }]
        });

        this.callParent(arguments);
    },

    //This is only a SHORT TERM solution. At first opportunity replace this file with an external
    //library reference
    getScript : function() {
        var text = '';

        text += "#------------------------------------------------------------------------------"  + this._newLine;
        text += "# supporting methods (and dragons, too) go here"  + this._newLine;
        text += "#------------------------------------------------------------------------------"  + this._newLine;
        text += "# GLOBAL VARIABLES, USED FOR PROJECTION STUFF"  + this._newLine;
        text += "east = 0.0"  + this._newLine;
        text += "north = 0.0"  + this._newLine;
        text += "#too lazy to properly refactor code used for UTM stuff"  + this._newLine;
        text += "pi = math.pi"  + this._newLine;
        text += "#these are based on WGS84"  + this._newLine;
        text += "#TODO modify for GDA94's spheroid (GRS80)"  + this._newLine;
        text += "sm_a = 6378137.0"  + this._newLine;
        text += "#sm_b different for GDA94 - 6356752.314140"  + this._newLine;
        text += "sm_b = 6356752.314"  + this._newLine;
        text += "#first eccentric squared different for GDA94"  + this._newLine;
        text += "#calculate as sm_EccSquared = 1 - (sm_b^2 / sm_a^2)"  + this._newLine;
        text += "sm_EccSquared = 6.69437999013e-03"  + this._newLine;
        text += "#Scale factor for UTM coordinates"  + this._newLine;
        text += "UTMScaleFactor = 0.9996"  + this._newLine;
        text += this._newLine;
        text += "# PROJECT" + this._newLine;
        text += "# This method does a nice projection from a latitude and longitude" + this._newLine;
        text += "# to an easting and northing wtihin a specified MGA zone." + this._newLine;
        text += "# Based on http://home.hiwaay.net/~taylorc/toolbox/geography/geoutm.html" + this._newLine;
        text += "#" + this._newLine;
        text += "# Could be replaced with the Python hook to the Proj/4 stuff:" + this._newLine;
        text += "# http://code.google.com/p/pyproj/" + this._newLine;
        text += "# or Python GDAL bindings" + this._newLine;
        text += "# http://pypi.python.org/pypi/GDAL/" + this._newLine;
        text += "# given I'm not sure what the portal of doom has on it, I might as well" + this._newLine;
        text += "# write some stuff so it Just Works (trademark, Steve Jobs)" + this._newLine;
        text += "# This'll do for now." + this._newLine;
        text += "def project(lat, lon, zone):" + this._newLine;
        text += this._tab + "east = 0.0" + this._newLine;
        text += this._tab + "north = 0.0" + this._newLine;
        text += this._tab + "east,north = LatLonToUTMXY(lat, lon, int(zone))" + this._newLine;
        text += this._tab + "return east,north" + this._newLine;
        text += this._newLine;
        text += "# Vestigial stuff from the projection work I borrowed." + this._newLine;
        text += "# Will remove one day." + this._newLine;
        text += "#" + this._newLine;
        text += "# DegToRad" + this._newLine;
        text += "def DegToRad(deg):" + this._newLine;
        text += this._tab + "return (deg / 180.0 * pi)" + this._newLine;
        text += this._newLine;
        text += "# RadToDeg" + this._newLine;
        text += "def RadToDeg(rad):" + this._newLine;
        text += this._tab + "return (rad / pi * 180.0)" + this._newLine;
        text += this._newLine;
        text += "# ArcLengthOfMeridian" + this._newLine;
        text += "# Computes the ellipsoidal distance from the equator to a point at a" + this._newLine;
        text += "# given latitude." + this._newLine;
        text += "# Reference: Hoffmann-Wellenhof, B., Lichtenegger, H., and Collins, J.," + this._newLine;
        text += "# GPS: Theory and Practice, 3rd ed.  New York: Springer-Verlag Wien, 1994." + this._newLine;
        text += "# Inputs:" + this._newLine;
        text += "#    phi - Latitude of the point, in radians." + this._newLine;
        text += "# Globals:" + this._newLine;
        text += "#    sm_a - Ellipsoid model major axis." + this._newLine;
        text += "#    sm_b - Ellipsoid model minor axis." + this._newLine;
        text += "# Returns:" + this._newLine;
        text += "#    The ellipsoidal distance of the point from the equator, in meters." + this._newLine;
        text += "def ArcLengthOfMeridian(phi):" + this._newLine;
        text += this._tab + "# precalculate n" + this._newLine;
        text += this._tab + "n = (sm_a - sm_b) / (sm_a + sm_b)" + this._newLine;
        text += this._tab + "# Precalculate alpha" + this._newLine;
        text += this._tab + "alpha = ((sm_a + sm_b) / 2.0) * (1.0 + (math.pow (n, 2.0) / 4.0) + (math.pow (n, 4.0) / 64.0))" + this._newLine;
        text += this._tab + "# Precalculate beta" + this._newLine;
        text += this._tab + "beta = (-3.0 * n / 2.0) + (9.0 * math.pow (n, 3.0) / 16.0) + (-3.0 * math.pow (n, 5.0) / 32.0)" + this._newLine;
        text += this._tab + "# Precalculate gamma" + this._newLine;
        text += this._tab + "gamma = (15.0 * math.pow (n, 2.0) / 16.0) + (-15.0 * math.pow (n, 4.0) / 32.0)" + this._newLine;
        text += this._tab + "# Precalculate delta" + this._newLine;
        text += this._tab + "delta = (-35.0 * math.pow (n, 3.0) / 48.0) + (105.0 * math.pow (n, 5.0) / 256.0)" + this._newLine;
        text += this._tab + "# Precalculate epsilon" + this._newLine;
        text += this._tab + "epsilon = (315.0 * math.pow (n, 4.0) / 512.0)" + this._newLine;
        text += this._tab + "# Now calculate the sum of the series and return" + this._newLine;
        text += this._tab + "result = alpha * (phi + (beta * math.sin (2.0 * phi)) + (gamma * math.sin (4.0 * phi)) + (delta * math.sin (6.0 * phi)) + (epsilon * math.sin (8.0 * phi)))" + this._newLine;
        text += this._tab + "return result" + this._newLine;
        text += this._newLine;
        text += "# UTMCentralMeridian" + this._newLine;
        text += "# Determines the central meridian for the given UTM zone." + this._newLine;
        text += "# Inputs:" + this._newLine;
        text += "#    zone - An integer value designating the UTM zone, range [1,60]." + this._newLine;
        text += "# Returns:" + this._newLine;
        text += "#   The central meridian for the given UTM zone, in radians, or zero" + this._newLine;
        text += "#   if the UTM zone parameter is outside the range [1,60]." + this._newLine;
        text += "#   Range of the central meridian is the radian equivalent of [-177,+177]." + this._newLine;
        text += "def UTMCentralMeridian(zone):" + this._newLine;
        text += this._tab + "cmeridian = math.radians(-183.0 + (zone * 6.0))" + this._newLine;
        text += this._tab + "return cmeridian" + this._newLine;
        text += this._newLine;
        text += "# FootpointLatitude" + this._newLine;
        text += "# Computes the footpoint latitude for use in converting transverse" + this._newLine;
        text += "# Mercator coordinates to ellipsoidal coordinates" + this._newLine;
        text += "# Reference: Hoffmann-Wellenhof, B., Lichtenegger, H., and Collins, J.," + this._newLine;
        text += "#   GPS: Theory and Practice, 3rd ed.  New York: Springer-Verlag Wien, 1994." + this._newLine;
        text += "# Inputs:" + this._newLine;
        text += "#   y - The UTM northing coordinate, in meters." + this._newLine;
        text += "# Returns:" + this._newLine;
        text += "#   The footpoint latitude, in radians." + this._newLine;
        text += "def FootpointLatitude(y):" + this._newLine;
        text += this._tab + "# Precalculate n (Eq. 10.18)" + this._newLine;
        text += this._tab + "n = (sm_a - sm_b) / (sm_a + sm_b)" + this._newLine;
        text += this._tab + "# Precalculate alpha_ (Eq. 10.22)" + this._newLine;
        text += this._tab + "# (Same as alpha in Eq. 10.17)" + this._newLine;
        text += this._tab + "alpha_ = ((sm_a + sm_b) / 2.0) * (1 + (math.pow (n, 2.0) / 4) + (math.pow (n, 4.0) / 64))" + this._newLine;
        text += this._tab + "# Precalculate y_ (Eq. 10.23)" + this._newLine;
        text += this._tab + "y_ = y / alpha_" + this._newLine;
        text += this._tab + "# Precalculate beta_ (Eq. 10.22)" + this._newLine;
        text += this._tab + "beta_ = (3.0 * n / 2.0) + (-27.0 * math.pow (n, 3.0) / 32.0) + (269.0 * math.pow (n, 5.0) / 512.0)" + this._newLine;
        text += this._tab + "# Precalculate gamma_ (Eq. 10.22)" + this._newLine;
        text += this._tab + "gamma_ = (21.0 * math.pow (n, 2.0) / 16.0) + (-55.0 * math.pow (n, 4.0) / 32.0)" + this._newLine;
        text += this._tab + "# Precalculate delta_ (Eq. 10.22)" + this._newLine;
        text += this._tab + "delta_ = (151.0 * math.pow (n, 3.0) / 96.0) + (-417.0 * math.pow (n, 5.0) / 128.0)" + this._newLine;
        text += this._tab + "# Precalculate epsilon_ (Eq. 10.22)" + this._newLine;
        text += this._tab + "epsilon_ = (1097.0 * math.pow (n, 4.0) / 512.0)" + this._newLine;
        text += this._tab + "# Now calculate the sum of the series (Eq. 10.21)" + this._newLine;
        text += this._tab + "result = y_ + (beta_ * math.sin (2.0 * y_)) + (gamma_ * math.sin (4.0 * y_)) + (delta_ * math.sin (6.0 * y_)) + (epsilon_ * math.sin (8.0 * y_))" + this._newLine;
        text += this._tab + "return result" + this._newLine;
        text += this._newLine;
        text += "# MapLatLonToXY" + this._newLine;
        text += "# Converts a latitude/longitude pair to x and y coordinates in the" + this._newLine;
        text += "# Transverse Mercator projection.  Note that Transverse Mercator is not" + this._newLine;
        text += "# the same as UTM; a scale factor is required to convert between them." + this._newLine;
        text += "# Reference: Hoffmann-Wellenhof, B., Lichtenegger, H., and Collins, J.," + this._newLine;
        text += "# GPS: Theory and Practice, 3rd ed.  New York: Springer-Verlag Wien, 1994." + this._newLine;
        text += "# Inputs:" + this._newLine;
        text += "#    phi - Latitude of the point, in radians." + this._newLine;
        text += "#    lambda - Longitude of the point, in radians." + this._newLine;
        text += "#    lambda0 - Longitude of the central meridian to be used, in radians." + this._newLine;
        text += "# Returns:" + this._newLine;
        text += "#    Two values, x and y: x and y coordinates of computed point, not scaled." + this._newLine;
        text += "def MapLatLonToXY(phi, lambda1, lambda0):" + this._newLine;
        text += this._tab + "x = 0.0" + this._newLine;
        text += this._tab + "y = 0.0" + this._newLine;
        text += this._tab + "# Precalculate ep2" + this._newLine;
        text += this._tab + "ep2 = (math.pow(sm_a, 2.0) - math.pow(sm_b, 2.0)) / math.pow(sm_b, 2.0)" + this._newLine;
        text += this._tab + "# Precalculate nu2" + this._newLine;
        text += this._tab + "nu2 = ep2 * math.pow(math.cos(phi), 2.0)" + this._newLine;
        text += this._tab + "# Precalculate N" + this._newLine;
        text += this._tab + "N = math.pow(sm_a, 2.0) / (sm_b * math.sqrt(1 + nu2))" + this._newLine;
        text += this._tab + "# Precalculate t" + this._newLine;
        text += this._tab + "t = math.tan(phi)" + this._newLine;
        text += this._tab + "t2 = t * t" + this._newLine;
        text += this._tab + "tmp = (t2 * t2 * t2) - math.pow(t, 6.0)" + this._newLine;
        text += this._tab + "# Precalculate l" + this._newLine;
        text += this._tab + "l = lambda1 - lambda0" + this._newLine;
        text += this._tab + "# Precalculate coefficients for l**n in the equations below" + this._newLine;
        text += this._tab + "# so a normal human being can read the expressions for easting" + this._newLine;
        text += this._tab + "# and northing" + this._newLine;
        text += this._tab + "#  -- l**1 and l**2 have coefficients of 1.0" + this._newLine;
        text += this._tab + "l3coef = 1.0 - t2 + nu2" + this._newLine;
        text += this._tab + "l4coef = 5.0 - t2 + 9 * nu2 + 4.0 * (nu2 * nu2)" + this._newLine;
        text += this._tab + "l5coef = 5.0 - 18.0 * t2 + (t2 * t2) + 14.0 * nu2 - 58.0 * t2 * nu2" + this._newLine;
        text += this._tab + "l6coef = 61.0 - 58.0 * t2 + (t2 * t2) + 270.0 * nu2 - 330.0 * t2 * nu2" + this._newLine;
        text += this._tab + "l7coef = 61.0 - 479.0 * t2 + 179.0 * (t2 * t2) - (t2 * t2 * t2)" + this._newLine;
        text += this._tab + "l8coef = 1385.0 - 3111.0 * t2 + 543.0 * (t2 * t2) - (t2 * t2 * t2)" + this._newLine;
        text += this._tab + "# Calculate easting (x)" + this._newLine;
        text += this._tab + "x = N * math.cos (phi) * l + (N / 6.0 * math.pow (math.cos (phi), 3.0) * l3coef * math.pow (l, 3.0)) + (N / 120.0 * math.pow (math.cos (phi), 5.0) * l5coef * math.pow (l, 5.0)) + (N / 5040.0 * math.pow (math.cos (phi), 7.0) * l7coef * math.pow (l, 7.0))" + this._newLine;
        text += this._tab + "# Calculate northing (y)" + this._newLine;
        text += this._tab + "y = ArcLengthOfMeridian (phi) + (t / 2.0 * N * math.pow (math.cos (phi), 2.0) * math.pow (l, 2.0)) + (t / 24.0 * N * math.pow (math.cos (phi), 4.0) * l4coef * math.pow (l, 4.0)) + (t / 720.0 * N * math.pow (math.cos (phi), 6.0) * l6coef * math.pow (l, 6.0)) + (t / 40320.0 * N * math.pow (math.cos (phi), 8.0) * l8coef * math.pow (l, 8.0))" + this._newLine;
        text += this._tab + "return x,y" + this._newLine;
        text += this._newLine;
        text += "# MapXYToLatLon" + this._newLine;
        text += "# TODO: Function not fixed for Python-ness 28/06/2011" + this._newLine;
        text += "# Converts x and y coordinates in the Transverse Mercator projection to" + this._newLine;
        text += "# a latitude/longitude pair.  Note that Transverse Mercator is not" + this._newLine;
        text += "# the same as UTM; a scale factor is required to convert between them." + this._newLine;
        text += "# Reference: Hoffmann-Wellenhof, B., Lichtenegger, H., and Collins, J.," + this._newLine;
        text += "#   GPS: Theory and Practice, 3rd ed.  New York: Springer-Verlag Wien, 1994." + this._newLine;
        text += "# Inputs:" + this._newLine;
        text += "#   x - The easting of the point, in meters." + this._newLine;
        text += "#   y - The northing of the point, in meters." + this._newLine;
        text += "#   lambda0 - Longitude of the central meridian to be used, in radians." + this._newLine;
        text += "# Outputs:" + this._newLine;
        text += "#   philambda - A 2-element containing the latitude and longitude" + this._newLine;
        text += "#                in radians." + this._newLine;
        text += "# Returns:" + this._newLine;
        text += "#   The function does not return a value." + this._newLine;
        text += "# Remarks:" + this._newLine;
        text += "#   The local variables Nf, nuf2, tf, and tf2 serve the same purpose as" + this._newLine;
        text += "#   N, nu2, t, and t2 in MapLatLonToXY, but they are computed with respect" + this._newLine;
        text += "#   to the footpoint latitude phif." + this._newLine;
        text += "#" + this._newLine;
        text += "#   x1frac, x2frac, x2poly, x3poly, etc. are to enhance readability and" + this._newLine;
        text += "#   to optimize computations." + this._newLine;
        text += "def MapXYToLatLon(x, y, lambda0, philambda):" + this._newLine;
        text += this._tab + "# Get the value of phif, the footpoint latitude." + this._newLine;
        text += this._tab + "phif = FootpointLatitude (y)" + this._newLine;
        text += this._tab + "# Precalculate ep2" + this._newLine;
        text += this._tab + "ep2 = (math.pow (sm_a, 2.0) - math.pow (sm_b, 2.0)) / math.pow (sm_b, 2.0)" + this._newLine;
        text += this._tab + "# Precalculate cos (phif)" + this._newLine;
        text += this._tab + "cf = math.cos (phif)" + this._newLine;
        text += this._tab + "# Precalculate nuf2" + this._newLine;
        text += this._tab + "nuf2 = ep2 * math.pow (cf, 2.0)" + this._newLine;
        text += this._tab + "# Precalculate Nf and initialize Nfpow" + this._newLine;
        text += this._tab + "Nf = math.pow (sm_a, 2.0) / (sm_b * math.sqrt (1 + nuf2))" + this._newLine;
        text += this._tab + "Nfpow = Nf" + this._newLine;
        text += this._tab +  "# Precalculate tf" + this._newLine;
        text += this._tab + "tf = math.tan (phif)" + this._newLine;
        text += this._tab + "tf2 = tf * tf" + this._newLine;
        text += this._tab + "tf4 = tf2 * tf2" + this._newLine;
        text += this._tab + "# Precalculate fractional coefficients for x**n in the equations" + this._newLine;
        text += this._tab + "# below to simplify the expressions for latitude and longitude." + this._newLine;
        text += this._tab + "x1frac = 1.0 / (Nfpow * cf)    " + this._newLine;
        text += this._tab + "Nfpow *= Nf            # now equals Nf**2" + this._newLine;
        text += this._tab + "x2frac = tf / (2.0 * Nfpow)" + this._newLine;
        text += this._tab + "Nfpow *= Nf            # now equals Nf**3" + this._newLine;
        text += this._tab + "x3frac = 1.0 / (6.0 * Nfpow * cf)" + this._newLine;
        text += this._tab + "Nfpow *= Nf        # now equals Nf**4" + this._newLine;
        text += this._tab + "x4frac = tf / (24.0 * Nfpow)" + this._newLine;
        text += this._tab + "Nfpow *= Nf        # now equals Nf**5" + this._newLine;
        text += this._tab + "x5frac = 1.0 / (120.0 * Nfpow * cf)" + this._newLine;
        text += this._tab + "Nfpow *= Nf        # now equals Nf**6" + this._newLine;
        text += this._tab + "x6frac = tf / (720.0 * Nfpow)" + this._newLine;
        text += this._tab + "Nfpow *= Nf        # now equals Nf**7" + this._newLine;
        text += this._tab + "x7frac = 1.0 / (5040.0 * Nfpow * cf)" + this._newLine;
        text += this._tab + "Nfpow *= Nf        # now equals Nf**8" + this._newLine;
        text += this._tab + "x8frac = tf / (40320.0 * Nfpow)" + this._newLine;
        text += this._tab + "# Precalculate polynomial coefficients for x**n." + this._newLine;
        text += this._tab + "#    -- x**1 does not have a polynomial coefficient." + this._newLine;
        text += this._tab + "x2poly = -1.0 - nuf2" + this._newLine;
        text += this._tab + "x3poly = -1.0 - 2 * tf2 - nuf2" + this._newLine;
        text += this._tab + "x4poly = 5.0 + 3.0 * tf2 + 6.0 * nuf2 - 6.0 * tf2 * nuf2 - 3.0 * (nuf2 *nuf2) - 9.0 * tf2 * (nuf2 * nuf2)" + this._newLine;
        text += this._tab + "x5poly = 5.0 + 28.0 * tf2 + 24.0 * tf4 + 6.0 * nuf2 + 8.0 * tf2 * nuf2" + this._newLine;
        text += this._tab + "x6poly = -61.0 - 90.0 * tf2 - 45.0 * tf4 - 107.0 * nuf2     + 162.0 * tf2 * nuf2" + this._newLine;
        text += this._tab + "x7poly = -61.0 - 662.0 * tf2 - 1320.0 * tf4 - 720.0 * (tf4 * tf2)" + this._newLine;
        text += this._tab + "x8poly = 1385.0 + 3633.0 * tf2 + 4095.0 * tf4 + 1575 * (tf4 * tf2)" + this._newLine;
        text += this._tab + "# Calculate latitude" + this._newLine;
        text += this._tab + "philambda[0] = phif + x2frac * x2poly * (x * x)    + x4frac * x4poly * math.pow (x, 4.0) + x6frac * x6poly * math.pow (x, 6.0) + x8frac * x8poly * math.pow (x, 8.0)" + this._newLine;
        text += this._tab + "# Calculate longitude" + this._newLine;
        text += this._tab + "philambda[1] = lambda0 + x1frac * x    + x3frac * x3poly * math.pow (x, 3.0) + x5frac * x5poly * math.pow (x, 5.0)    + x7frac * x7poly * math.pow (x, 7.0)" + this._newLine;
        text += this._tab + "return" + this._newLine;
        text += this._newLine;
        text += "# LatLonToUTMXY" + this._newLine;
        text += "# Converts a latitude/longitude pair to x and y coordinates in the" + this._newLine;
        text += "# Universal Transverse Mercator projection." + this._newLine;
        text += "# Inputs:" + this._newLine;
        text += "#   lat - Latitude of the point, in degrees." + this._newLine;
        text += "#   lon - Longitude of the point, in degrees." + this._newLine;
        text += "#   zone - UTM zone to be used for calculating values for x and y." + this._newLine;
        text += "#          If zone is less than 1 or greater than 60, the routine" + this._newLine;
        text += "#          will determine the appropriate zone from the value of lon." + this._newLine;
        text += "# Outputs:" + this._newLine;
        text += "#   xy - A 2-element array where the UTM x and y values will be stored." + this._newLine;
        text += "# Returns:" + this._newLine;
        text += "#   The UTM zone used for calculating the values of x and y." + this._newLine;
        text += "def LatLonToUTMXY(lat, lon, zone):" + this._newLine;
        text += this._tab + "east,north = MapLatLonToXY(math.radians(lat), math.radians(lon), UTMCentralMeridian (zone))" + this._newLine;
        text += this._tab + "# Adjust easting and northing for UTM system." + this._newLine;
        text += this._tab + "# magic number on the easting (500000) is the false easting" + this._newLine;
        text += this._tab + "east = east * UTMScaleFactor + 500000.0" + this._newLine;
        text += this._tab + "north = north * UTMScaleFactor" + this._newLine;
        text += this._tab + "# this is used to add the false northing for southern hemisphere values" + this._newLine;
        text += this._tab + "if (north < 0.0):" + this._newLine;
        text += this._tab + this._tab + "north = north + 10000000.0" + this._newLine;
        text += this._tab + "return east,north" + this._newLine;
        text += this._newLine;
        text += "# UTMXYToLatLon" + this._newLine;
        text += "# Converts x and y coordinates in the Universal Transverse Mercator" + this._newLine;
        text += "# projection to a latitude/longitude pair." + this._newLine;
        text += "# Inputs:" + this._newLine;
        text += "#    x - The easting of the point, in meters." + this._newLine;
        text += "#    y - The northing of the point, in meters." + this._newLine;
        text += "#    zone - The UTM zone in which the point lies." + this._newLine;
        text += "#    southhemi - True if the point is in the southern hemisphere;" + this._newLine;
        text += "#                false otherwise." + this._newLine;
        text += "# Outputs:" + this._newLine;
        text += "#    latlon - A 2-element array containing the latitude and" + this._newLine;
        text += "#             longitude of the point, in radians." + this._newLine;
        text += "# Returns:" + this._newLine;
        text += "#    The function does not return a value." + this._newLine;
        text += "def UTMXYToLatLon(x, y, zone, southhemi, latlon):" + this._newLine;
        text += this._tab + "x -= 500000.0" + this._newLine;
        text += this._tab + "x /= UTMScaleFactor" + this._newLine;
        text += this._tab + "# If in southern hemisphere, adjust y accordingly." + this._newLine;
        text += this._tab + "if (southhemi):" + this._newLine;
        text += this._tab + this._tab + "y -= 10000000.0" + this._newLine;
        text += this._tab + "y /= UTMScaleFactor" + this._newLine;
        text += this._tab + "cmeridian = UTMCentralMeridian (zone)" + this._newLine;
        text += this._tab + "MapXYToLatLon (x, y, cmeridian, latlon)" + this._newLine;
        text += this._tab + "return" + this._newLine;
        text += this._tab + "" + this._newLine;
        text += "#------------------------------------------------------------------------------" + this._newLine;
        text += "# Methods other than function projection stuff down here" + this._newLine;
        text += "#------------------------------------------------------------------------------" + this._newLine;
        text += "# GET_MAG_FIELD" + this._newLine;
        text += "# This is a method which gets the magnetic field things we need" + this._newLine;
        text += "# Needs a latitude and longitude and an 'epoch' - time we want the mag field for" + this._newLine;
        text += "# A few URLs can be used to get this" + this._newLine;
        text += "# http://www.ngdc.noaa.gov/geomag/magfield.shtml" + this._newLine;
        text += "# http://www.ga.gov.au/oracle/geomag/agrfform.jsp" + this._newLine;
        text += "# example of the GA one, using AGRF" + this._newLine;
        text += "# http://www.ga.gov.au/bin/geoAGRF?latd=-24&latm=00&lats=00&lond=135&lonm=00&lons=00&elev=0&year=2010&month=01&day=1&Ein=D" + this._newLine;
        text += "#" + this._newLine;
        text += "#TODO: Make it a bit more awesome" + this._newLine;
        text += "def get_mag_field(lat, lon, year, month, day):" + this._newLine;
        text += this._tab + "#some defaults so it doesn't fall over" + this._newLine;
        text += this._tab + "declination = 0.0" + this._newLine;
        text += this._tab + "inclination = 0.0" + this._newLine;
        text += this._tab + "intensity = 50000.0" + this._newLine;
        text += this._tab + "#for AGRF call we need decimal degrees turned into lats and lons" + this._newLine;
        text += this._tab + "latd,latm,lats = decdeg2dms(lat)" + this._newLine;
        text += this._tab + "lond,lonm,lons = decdeg2dms(lon)" + this._newLine;
        text += this._tab + "#assume zero elevation" + this._newLine;
        text += this._tab + "elev = 0" + this._newLine;
        text += this._tab + "#successive formatting of URL to make it a bit easier to read" + this._newLine;
        text += this._tab + "#urlencode doesn't work very well for some reason, but this handcoded way does" + this._newLine;
        text += this._tab + "#base URL for AGRF online calculation as of 1 July 2011" + this._newLine;
        text += this._tab + "base_url = 'http://www.ga.gov.au/bin/geoAGRF?'" + this._newLine;
        text += this._tab + "#latitude stuff" + this._newLine;
        text += this._tab + "full_url = base_url + 'latd=' + str(latd) + '&latm=' + str(latm) + '&lats=' + str(lats)" + this._newLine;
        text += this._tab + "#longitude stuff" + this._newLine;
        text += this._tab + "full_url = full_url + '&lond=' + str(lond) + '&lonm=' + str(lonm) + '&lons=' + str(lons)" + this._newLine;
        text += this._tab + "#elevation stuff" + this._newLine;
        text += this._tab + "full_url = full_url + '&elev=' + str(elev)" + this._newLine;
        text += this._tab + "#epoch stuff" + this._newLine;
        text += this._tab + "full_url = full_url + '&year=' + str(year) + '&month=' + str(month) + '&day=' + str(day)" + this._newLine;
        text += this._tab + "#We want three components - D is declination, I is inclination, F is total field strength" + this._newLine;
        text += this._tab + "full_url = full_url + '&Ein=D&Ein=I&Ein=F'" + this._newLine;
        text += this._tab + "" + this._newLine;
        text += this._tab + "#debugging: what URL are we retrieving?" + this._newLine;
        text += this._tab + "print 'Retrieving the following URL: ' + full_url" + this._newLine;
        text += this._tab + "#open the URL, read its full contents into a variable" + this._newLine;
        text += this._tab + "f = urllib.urlopen(full_url)" + this._newLine;
        text += this._tab + "agrf_page_contents = f.read()" + this._newLine;
        text += this._tab + "" + this._newLine;
        text += this._tab + "#now we need to extract the small section of the page we're looking for" + this._newLine;
        text += this._tab + "#As of 1 July 2011, it is bounced by <br><b>Magnetic Field Components<br> and a newline</b><br>" + this._newLine;
        text += this._tab + "#Find the start string, and 41 characters to this position index to strip out" + this._newLine;
        text += this._tab + "#the Magnetic Field Components sentence & formatting characteristics" + this._newLine;
        text += this._tab + "start_index = agrf_page_contents.find('<br><b>Magnetic Field Components<br>') + 41" + this._newLine;
        text += this._tab + "#End index is easier to define" + this._newLine;
        text += this._tab + "end_index = agrf_page_contents.find('\\n</b><br>')" + this._newLine;
        text += this._tab + "#Extract the text between the two indices we defined above" + this._newLine;
        text += this._tab + "components_contents = agrf_page_contents[start_index:end_index]" + this._newLine;
        text += this._tab + "#Now we can split them with a newline and <br> delimiter" + this._newLine;
        text += this._tab + "#Will provide 3 'component' strings" + this._newLine;
        text += this._tab + "for component in components_contents.split('\\n<br>'):" + this._newLine;
        text += this._tab + this._tab + "#Check the first character and remove the leading characters" + this._newLine;
        text += this._tab + this._tab + "#and convert the extracted text to a float" + this._newLine;
        text += this._tab + this._tab + "#D means declination..." + this._newLine;
        text += this._tab + this._tab + "if component[0:1] == 'D':" + this._newLine;
        text += this._tab + this._tab + this._tab + "declination = float(component[4:-3])" + this._newLine;
        text += this._tab + this._tab + "#I means inclination..." + this._newLine;
        text += this._tab + this._tab + "if component[0:1] == 'I':" + this._newLine;
        text += this._tab + this._tab + this._tab + "inclination = float(component[4:-3])" + this._newLine;
        text += this._tab + this._tab + "#and F means total field intensity" + this._newLine;
        text += this._tab + this._tab + "if component[0:1] == 'F':" + this._newLine;
        text += this._tab + this._tab + this._tab + "intensity = float(component[4:-3])" + this._newLine;
        text += this._tab + "return declination,inclination,intensity" + this._newLine;
        text += this._newLine;
        text += "# DECDEG2DMS" + this._newLine;
        text += "# Converts a decimal degree number into degrees, minutes and seconds." + this._newLine;
        text += "def decdeg2dms(dd):" + this._newLine;
        text += this._tab + "mnt,sec = divmod(dd*3600,60)" + this._newLine;
        text += this._tab + "deg,mnt = divmod(mnt,60)" + this._newLine;
        text += this._tab + "return deg,mnt,sec" + this._newLine;

        return text;
    }
});
